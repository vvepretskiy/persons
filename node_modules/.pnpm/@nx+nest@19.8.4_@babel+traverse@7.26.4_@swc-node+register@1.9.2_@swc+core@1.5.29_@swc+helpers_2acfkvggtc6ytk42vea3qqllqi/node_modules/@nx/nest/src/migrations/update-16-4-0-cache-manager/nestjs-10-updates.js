"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateNestJs10 = updateNestJs10;
exports.updateCacheManagerImport = updateCacheManagerImport;
exports.updateTsConfigTarget = updateTsConfigTarget;
const devkit_1 = require("@nx/devkit");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const typescript_1 = require("typescript");
const JS_TS_FILE_MATCHER = /\.[jt]sx?$/;
const importMatch = ':matches(ImportDeclaration, VariableStatement):has(Identifier[name="CacheModule"], Identifier[name="CacheModule"]):has(StringLiteral[value="@nestjs/common"])';
async function updateNestJs10(tree) {
    const nestProjects = await getNestProejcts();
    if (nestProjects.length === 0) {
        return;
    }
    let installCacheModuleDeps = false;
    const projects = (0, devkit_1.getProjects)(tree);
    for (const projectName of nestProjects) {
        const projectConfig = projects.get(projectName);
        const tsConfig = projectConfig.targets?.build?.options?.tsConfig ??
            (0, devkit_1.joinPathFragments)(projectConfig.root, projectConfig.projectType === 'application'
                ? 'tsconfig.app.json'
                : 'tsconfig.lib.json');
        if (tree.exists(tsConfig)) {
            updateTsConfigTarget(tree, tsConfig);
        }
        (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfig.root, (filePath) => {
            if (!JS_TS_FILE_MATCHER.test(filePath)) {
                return;
            }
            installCacheModuleDeps =
                updateCacheManagerImport(tree, filePath) || installCacheModuleDeps;
        });
    }
    await (0, devkit_1.formatFiles)(tree);
    return installCacheModuleDeps
        ? (0, devkit_1.addDependenciesToPackageJson)(tree, {
            '@nestjs/cache-manager': '^2.0.0',
            'cache-manager': '^5.2.3',
        }, {})
        : () => { };
}
async function getNestProejcts() {
    const projectGraph = await (0, devkit_1.createProjectGraphAsync)();
    return Object.entries(projectGraph.dependencies)
        .filter(([node, dep]) => dep.some(({ target }) => !projectGraph.externalNodes?.[node] && target === 'npm:@nestjs/common'))
        .map(([projectName]) => projectName);
}
// change import { CacheModule } from '@nestjs/common';
// to import { CacheModule } from '@nestjs/cache-manager';
function updateCacheManagerImport(tree, filePath) {
    const content = tree.read(filePath, 'utf-8');
    const updated = tsquery_1.tsquery.replace(content, importMatch, (node) => {
        const text = node.getText();
        return `${text.replace('CacheModule', '')}\n${(0, typescript_1.isVariableStatement)(node)
            ? "const { CacheModule } = require('@nestjs/cache-manager')"
            : "import { CacheModule } from '@nestjs/cache-manager';"}`;
    });
    if (updated !== content) {
        tree.write(filePath, updated);
        return true;
    }
}
function updateTsConfigTarget(tree, tsConfigPath) {
    (0, devkit_1.updateJson)(tree, tsConfigPath, (json) => {
        if (!json.compilerOptions.target) {
            return json;
        }
        const normalizedTargetName = json.compilerOptions.target.toUpperCase();
        // es6 isn't apart of the ScriptTarget enum but is a valid tsconfig target in json file
        const existingTarget = normalizedTargetName === 'ES6'
            ? typescript_1.ScriptTarget.ES2015
            : typescript_1.ScriptTarget[normalizedTargetName];
        if (existingTarget < typescript_1.ScriptTarget.ES2021) {
            json.compilerOptions.target = 'es2021';
        }
        return json;
    });
}
exports.default = updateNestJs10;
