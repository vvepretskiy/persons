"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createNodesV2 = void 0;
const devkit_1 = require("@nx/devkit");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const fs_1 = require("fs");
const minimatch_1 = require("minimatch");
const devkit_internals_1 = require("nx/src/devkit-internals");
const package_json_1 = require("nx/src/plugins/package-json");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const globs_1 = require("nx/src/utils/globs");
const path_1 = require("path");
const version_utils_1 = require("../utils/version-utils");
const pmc = (0, devkit_1.getPackageManagerCommand)();
function readTargetsCache(cachePath) {
    return (0, fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
const jestConfigGlob = '**/jest.config.{cjs,mjs,js,cts,mts,ts}';
exports.createNodesV2 = [
    jestConfigGlob,
    async (configFiles, options, context) => {
        const optionsHash = (0, devkit_internals_1.hashObject)(options);
        const cachePath = (0, path_1.join)(cache_directory_1.workspaceDataDirectory, `jest-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        try {
            return await (0, devkit_1.createNodesFromFiles)((configFile, options, context) => createNodesInternal(configFile, options, context, targetsCache), configFiles, options, context);
        }
        finally {
            writeTargetsToCache(cachePath, targetsCache);
        }
    },
];
/**
 * @deprecated This is replaced with {@link createNodesV2}. Update your plugin to export its own `createNodesV2` function that wraps this one instead.
 * This function will change to the v2 function in Nx 20.
 */
exports.createNodes = [
    jestConfigGlob,
    (...args) => {
        devkit_1.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        return createNodesInternal(...args, {});
    },
];
async function createNodesInternal(configFilePath, options, context, targetsCache) {
    const projectRoot = (0, path_1.dirname)(configFilePath);
    const packageManagerWorkspacesGlob = (0, globs_1.combineGlobPatterns)((0, package_json_1.getGlobPatternsFromPackageManagerWorkspaces)(context.workspaceRoot));
    // Do not create a project if package.json and project.json isn't there.
    const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
    if (!siblingFiles.includes('package.json') &&
        !siblingFiles.includes('project.json')) {
        return {};
    }
    else if (!siblingFiles.includes('project.json') &&
        siblingFiles.includes('package.json')) {
        const path = (0, devkit_1.joinPathFragments)(projectRoot, 'package.json');
        const isPackageJsonProject = (0, minimatch_1.minimatch)(path, packageManagerWorkspacesGlob);
        if (!isPackageJsonProject) {
            return {};
        }
    }
    const jestConfigContent = (0, fs_1.readFileSync)((0, path_1.resolve)(context.workspaceRoot, configFilePath), 'utf-8');
    if (jestConfigContent.includes('getJestProjectsAsync()')) {
        // The `getJestProjectsAsync` function uses the project graph, which leads to a
        // circular dependency. We can skip this since it's no intended to be used for
        // an Nx project.
        return {};
    }
    options = normalizeOptions(options);
    const hash = await (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context);
    targetsCache[hash] ??= await buildJestTargets(configFilePath, projectRoot, options, context);
    const { targets, metadata } = targetsCache[hash];
    return {
        projects: {
            [projectRoot]: {
                root: projectRoot,
                targets,
                metadata,
            },
        },
    };
}
async function buildJestTargets(configFilePath, projectRoot, options, context) {
    const absConfigFilePath = (0, path_1.resolve)(context.workspaceRoot, configFilePath);
    if (require.cache[absConfigFilePath]) {
        (0, config_utils_1.clearRequireCache)();
    }
    const rawConfig = await (0, config_utils_1.loadConfigFile)(absConfigFilePath);
    const { readConfig } = requireJestUtil('jest-config', projectRoot, context.workspaceRoot);
    const config = await readConfig({
        _: [],
        $0: undefined,
    }, rawConfig, undefined, (0, path_1.dirname)(absConfigFilePath));
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const targets = {};
    const target = (targets[options.targetName] = {
        command: 'jest',
        options: {
            cwd: projectRoot,
        },
        metadata: {
            technologies: ['jest'],
            description: 'Run Jest Tests',
            help: {
                command: `${pmc.exec} jest --help`,
                example: {
                    options: {
                        coverage: true,
                    },
                },
            },
        },
    });
    const cache = (target.cache = true);
    const inputs = (target.inputs = getInputs(namedInputs, rawConfig, projectRoot, context.workspaceRoot));
    const outputs = (target.outputs = getOutputs(projectRoot, config, context));
    let metadata;
    if (options?.ciTargetName) {
        // nx-ignore-next-line
        const { default: Runtime } = requireJestUtil('jest-runtime', projectRoot, context.workspaceRoot);
        const jestContext = await Runtime.createContext(config.projectConfig, {
            maxWorkers: 1,
            watchman: false,
        });
        const jest = require(resolveJestPath(projectRoot, context.workspaceRoot));
        const source = new jest.SearchSource(jestContext);
        const jestVersion = (0, version_utils_1.getInstalledJestMajorVersion)();
        const specs = jestVersion >= 30
            ? // @ts-expect-error Jest 30+ expects the project config as the second argument
                await source.getTestPaths(config.globalConfig, config.projectConfig)
            : await source.getTestPaths(config.globalConfig);
        const testPaths = new Set(specs.tests.map(({ path }) => path));
        if (testPaths.size > 0) {
            const groupName = 'E2E (CI)';
            const targetGroup = [];
            metadata = {
                targetGroups: {
                    [groupName]: targetGroup,
                },
            };
            const dependsOn = [];
            targets[options.ciTargetName] = {
                executor: 'nx:noop',
                cache: true,
                inputs,
                outputs,
                dependsOn,
                metadata: {
                    technologies: ['jest'],
                    description: 'Run Jest Tests in CI',
                    nonAtomizedTarget: options.targetName,
                    help: {
                        command: `${pmc.exec} jest --help`,
                        example: {
                            options: {
                                coverage: true,
                            },
                        },
                    },
                },
            };
            targetGroup.push(options.ciTargetName);
            for (const testPath of testPaths) {
                const relativePath = (0, devkit_1.normalizePath)((0, path_1.relative)((0, path_1.join)(context.workspaceRoot, projectRoot), testPath));
                const targetName = `${options.ciTargetName}--${relativePath}`;
                dependsOn.push(targetName);
                targets[targetName] = {
                    command: `jest ${relativePath}`,
                    cache,
                    inputs,
                    outputs,
                    options: {
                        cwd: projectRoot,
                    },
                    metadata: {
                        technologies: ['jest'],
                        description: `Run Jest Tests in ${relativePath}`,
                        help: {
                            command: `${pmc.exec} jest --help`,
                            example: {
                                options: {
                                    coverage: true,
                                },
                            },
                        },
                    },
                };
                targetGroup.push(targetName);
            }
        }
    }
    return { targets, metadata };
}
function getInputs(namedInputs, jestConfig, projectRoot, workspaceRoot) {
    const inputs = [
        ...('production' in namedInputs
            ? ['default', '^production']
            : ['default', '^default']),
    ];
    const externalDependencies = ['jest'];
    const presetInput = resolvePresetInput(jestConfig.preset, projectRoot, workspaceRoot);
    if (presetInput) {
        if (typeof presetInput !== 'string' &&
            'externalDependencies' in presetInput) {
            externalDependencies.push(...presetInput.externalDependencies);
        }
        else {
            inputs.push(presetInput);
        }
    }
    inputs.push({ externalDependencies });
    return inputs;
}
// preset resolution adapted from:
// https://github.com/jestjs/jest/blob/c54bccd657fb4cf060898717c09f633b4da3eec4/packages/jest-config/src/normalize.ts#L122
function resolvePresetInput(presetValue, projectRoot, workspaceRoot) {
    if (!presetValue) {
        return null;
    }
    const { replaceRootDirInPath } = requireJestUtil('jest-config', projectRoot, workspaceRoot);
    let presetPath = replaceRootDirInPath(projectRoot, presetValue);
    const isNpmPackage = !presetValue.startsWith('.') && !(0, path_1.isAbsolute)(presetPath);
    presetPath = presetPath.startsWith('.')
        ? presetPath
        : (0, path_1.join)(presetPath, 'jest-preset');
    const { default: jestResolve } = requireJestUtil('jest-resolve', projectRoot, workspaceRoot);
    const presetModule = jestResolve.findNodeModule(presetPath, {
        basedir: projectRoot,
        extensions: ['.json', '.js', '.cjs', '.mjs'],
    });
    if (!presetModule) {
        return null;
    }
    if (isNpmPackage) {
        return { externalDependencies: [presetValue] };
    }
    const relativePath = (0, path_1.relative)((0, path_1.join)(workspaceRoot, projectRoot), presetModule);
    return relativePath.startsWith('..')
        ? (0, path_1.join)('{workspaceRoot}', (0, path_1.join)(projectRoot, relativePath))
        : (0, path_1.join)('{projectRoot}', relativePath);
}
function getOutputs(projectRoot, { globalConfig }, context) {
    function getOutput(path) {
        const relativePath = (0, path_1.relative)((0, path_1.join)(context.workspaceRoot, projectRoot), path);
        if (relativePath.startsWith('..')) {
            return (0, path_1.join)('{workspaceRoot}', (0, path_1.join)(projectRoot, relativePath));
        }
        else {
            return (0, path_1.join)('{projectRoot}', relativePath);
        }
    }
    const outputs = [];
    for (const outputOption of [
        globalConfig.coverageDirectory,
        globalConfig.outputFile,
    ]) {
        if (outputOption) {
            outputs.push(getOutput(outputOption));
        }
    }
    return outputs;
}
function normalizeOptions(options) {
    options ??= {};
    options.targetName ??= 'test';
    return options;
}
let resolvedJestPaths;
function resolveJestPath(projectRoot, workspaceRoot) {
    resolvedJestPaths ??= {};
    if (resolvedJestPaths[projectRoot]) {
        return resolvedJestPaths[projectRoot];
    }
    resolvedJestPaths[projectRoot] = require.resolve('jest', {
        paths: [projectRoot, workspaceRoot, __dirname],
    });
    return resolvedJestPaths[projectRoot];
}
let resolvedJestCorePaths;
/**
 * Resolves a jest util package version that `jest` is using.
 */
function requireJestUtil(packageName, projectRoot, workspaceRoot) {
    const jestPath = resolveJestPath(projectRoot, workspaceRoot);
    resolvedJestCorePaths ??= {};
    if (!resolvedJestCorePaths[jestPath]) {
        // nx-ignore-next-line
        resolvedJestCorePaths[jestPath] = require.resolve('@jest/core', {
            paths: [(0, path_1.dirname)(jestPath)],
        });
    }
    return require(require.resolve(packageName, {
        paths: [(0, path_1.dirname)(resolvedJestCorePaths[jestPath])],
    }));
}
