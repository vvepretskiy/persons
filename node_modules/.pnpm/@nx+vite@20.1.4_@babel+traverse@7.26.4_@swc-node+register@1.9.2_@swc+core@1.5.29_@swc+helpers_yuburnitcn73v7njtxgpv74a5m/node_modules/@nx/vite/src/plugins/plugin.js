"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    createDependencies: function() {
        return createDependencies;
    },
    createNodes: function() {
        return createNodes;
    },
    createNodesV2: function() {
        return createNodesV2;
    }
});
const _object_without_properties_loose = require("@swc/helpers/_/_object_without_properties_loose");
const _devkit = require("@nx/devkit");
const _path = require("path");
const _getnamedinputs = require("@nx/devkit/src/utils/get-named-inputs");
const _fs = require("fs");
const _calculatehashforcreatenodes = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const _cachedirectory = require("nx/src/utils/cache-directory");
const _js = require("@nx/js");
const _executorutils = require("../utils/executor-utils");
const _filehasher = require("nx/src/hasher/file-hasher");
const _minimatch = require("minimatch");
const pmc = (0, _devkit.getPackageManagerCommand)();
function readTargetsCache(cachePath) {
    return (0, _fs.existsSync)(cachePath) ? (0, _devkit.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, _devkit.writeJsonFile)(cachePath, results);
}
const createDependencies = ()=>{
    return [];
};
const viteVitestConfigGlob = '**/{vite,vitest}.config.{js,ts,mjs,mts,cjs,cts}';
const createNodesV2 = [
    viteVitestConfigGlob,
    async (configFilePaths, options, context)=>{
        const optionsHash = (0, _filehasher.hashObject)(options);
        const cachePath = (0, _path.join)(_cachedirectory.workspaceDataDirectory, `vite-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        try {
            return await (0, _devkit.createNodesFromFiles)((configFile, options, context)=>createNodesInternal(configFile, options, context, targetsCache), configFilePaths, options, context);
        } finally{
            writeTargetsToCache(cachePath, targetsCache);
        }
    }
];
const createNodes = [
    viteVitestConfigGlob,
    async (configFilePath, options, context)=>{
        _devkit.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        return createNodesInternal(configFilePath, options, context, {});
    }
];
async function createNodesInternal(configFilePath, options, context, targetsCache) {
    var _targetsCache, _hash;
    const projectRoot = (0, _path.dirname)(configFilePath);
    // Do not create a project if package.json and project.json isn't there.
    const siblingFiles = (0, _fs.readdirSync)((0, _path.join)(context.workspaceRoot, projectRoot));
    if (!siblingFiles.includes('package.json') && !siblingFiles.includes('project.json')) {
        return {};
    }
    var _siblingFiles_filter;
    const tsConfigFiles = (_siblingFiles_filter = siblingFiles.filter((p)=>(0, _minimatch.minimatch)(p, 'tsconfig*{.json,.*.json}'))) != null ? _siblingFiles_filter : [];
    const normalizedOptions = normalizeOptions(options);
    // We do not want to alter how the hash is calculated, so appending the config file path to the hash
    // to prevent vite/vitest files overwriting the target cache created by the other
    const hash = await (0, _calculatehashforcreatenodes.calculateHashForCreateNodes)(projectRoot, normalizedOptions, context, [
        (0, _js.getLockFileName)((0, _devkit.detectPackageManager)(context.workspaceRoot))
    ]) + configFilePath;
    const _ref = await buildViteTargets(configFilePath, projectRoot, normalizedOptions, tsConfigFiles, context), { isLibrary } = _ref, viteTargets = _object_without_properties_loose._(_ref, [
        "isLibrary"
    ]);
    var _;
    (_ = (_targetsCache = targetsCache)[_hash = hash]) != null ? _ : _targetsCache[_hash] = viteTargets;
    const { targets, metadata } = targetsCache[hash];
    const project = {
        root: projectRoot,
        targets,
        metadata
    };
    // If project is buildable, then the project type.
    // If it is not buildable, then leave it to other plugins/project.json to set the project type.
    if (project.targets[options.buildTargetName]) {
        project.projectType = isLibrary ? 'library' : 'application';
    }
    return {
        projects: {
            [projectRoot]: project
        }
    };
}
async function buildViteTargets(configFilePath, projectRoot, options, tsConfigFiles, context) {
    var _viteBuildConfig_build;
    const absoluteConfigFilePath = (0, _devkit.joinPathFragments)(context.workspaceRoot, configFilePath);
    // Workaround for the `build$3 is not a function` error that we sometimes see in agents.
    // This should be removed later once we address the issue properly
    try {
        const importEsbuild = ()=>new Function('return import("esbuild")')();
        await importEsbuild();
    } catch (e) {
    // do nothing
    }
    const { resolveConfig } = await (0, _executorutils.loadViteDynamicImport)();
    const viteBuildConfig = await resolveConfig({
        configFile: absoluteConfigFilePath,
        mode: 'development'
    }, 'build');
    const { buildOutputs, testOutputs, hasTest, isBuildable, hasServeConfig } = getOutputs(viteBuildConfig, projectRoot, context.workspaceRoot);
    const namedInputs = (0, _getnamedinputs.getNamedInputs)(projectRoot, context);
    const targets = {};
    // If file is not vitest.config and buildable, create targets for build, serve, preview and serve-static
    const hasRemixPlugin = viteBuildConfig.plugins && viteBuildConfig.plugins.some((p)=>p.name === 'remix');
    if (!configFilePath.includes('vitest.config') && !hasRemixPlugin && isBuildable) {
        var _viteBuildConfig_build1;
        targets[options.buildTargetName] = await buildTarget(options.buildTargetName, namedInputs, buildOutputs, projectRoot);
        // If running in library mode, then there is nothing to serve.
        if (!((_viteBuildConfig_build1 = viteBuildConfig.build) == null ? void 0 : _viteBuildConfig_build1.lib) || hasServeConfig) {
            targets[options.serveTargetName] = serveTarget(projectRoot);
            targets[options.previewTargetName] = previewTarget(projectRoot, options.buildTargetName);
            targets[options.serveStaticTargetName] = serveStaticTarget(options);
        }
    }
    if (tsConfigFiles.length) {
        var _find;
        const tsConfigToUse = (_find = [
            'tsconfig.app.json',
            'tsconfig.lib.json',
            'tsconfig.json'
        ].find((t)=>tsConfigFiles.includes(t))) != null ? _find : tsConfigFiles[0];
        targets[options.typecheckTargetName] = {
            cache: true,
            inputs: [
                ...'production' in namedInputs ? [
                    'production',
                    '^production'
                ] : [
                    'default',
                    '^default'
                ],
                {
                    externalDependencies: [
                        'typescript'
                    ]
                }
            ],
            command: `tsc --noEmit -p ${tsConfigToUse}`,
            options: {
                cwd: (0, _devkit.joinPathFragments)(projectRoot)
            },
            metadata: {
                description: `Run Typechecking`,
                help: {
                    command: `${pmc.exec} tsc --help -p ${tsConfigToUse}`,
                    example: {
                        options: {
                            noEmit: true
                        }
                    }
                }
            }
        };
    }
    // if file is vitest.config or vite.config has definition for test, create target for test
    if (configFilePath.includes('vitest.config') || hasTest) {
        targets[options.testTargetName] = await testTarget(namedInputs, testOutputs, projectRoot);
    }
    const metadata = {};
    return {
        targets,
        metadata,
        isLibrary: Boolean((_viteBuildConfig_build = viteBuildConfig.build) == null ? void 0 : _viteBuildConfig_build.lib)
    };
}
async function buildTarget(buildTargetName, namedInputs, outputs, projectRoot) {
    return {
        command: `vite build`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        },
        cache: true,
        dependsOn: [
            `^${buildTargetName}`
        ],
        inputs: [
            ...'production' in namedInputs ? [
                'production',
                '^production'
            ] : [
                'default',
                '^default'
            ],
            {
                externalDependencies: [
                    'vite'
                ]
            }
        ],
        outputs,
        metadata: {
            technologies: [
                'vite'
            ],
            description: `Run Vite build`,
            help: {
                command: `${pmc.exec} vite build --help`,
                example: {
                    options: {
                        sourcemap: true,
                        manifest: 'manifest.json'
                    }
                }
            }
        }
    };
}
function serveTarget(projectRoot) {
    const targetConfig = {
        command: `vite serve`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        },
        metadata: {
            technologies: [
                'vite'
            ],
            description: `Starts Vite dev server`,
            help: {
                command: `${pmc.exec} vite --help`,
                example: {
                    options: {
                        port: 3000
                    }
                }
            }
        }
    };
    return targetConfig;
}
function previewTarget(projectRoot, buildTargetName) {
    const targetConfig = {
        command: `vite preview`,
        dependsOn: [
            buildTargetName
        ],
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        },
        metadata: {
            technologies: [
                'vite'
            ],
            description: `Locally preview Vite production build`,
            help: {
                command: `${pmc.exec} vite preview --help`,
                example: {
                    options: {
                        port: 3000
                    }
                }
            }
        }
    };
    return targetConfig;
}
async function testTarget(namedInputs, outputs, projectRoot) {
    return {
        command: `vitest`,
        options: {
            cwd: (0, _devkit.joinPathFragments)(projectRoot)
        },
        cache: true,
        inputs: [
            ...'production' in namedInputs ? [
                'default',
                '^production'
            ] : [
                'default',
                '^default'
            ],
            {
                externalDependencies: [
                    'vitest'
                ]
            },
            {
                env: 'CI'
            }
        ],
        outputs,
        metadata: {
            technologies: [
                'vite'
            ],
            description: `Run Vite tests`,
            help: {
                command: `${pmc.exec} vitest --help`,
                example: {
                    options: {
                        bail: 1,
                        coverage: true
                    }
                }
            }
        }
    };
}
function serveStaticTarget(options) {
    const targetConfig = {
        executor: '@nx/web:file-server',
        options: {
            buildTarget: `${options.buildTargetName}`,
            spa: true
        }
    };
    return targetConfig;
}
function getOutputs(viteBuildConfig, projectRoot, workspaceRoot) {
    var _build_rollupOptions, _test_coverage;
    const { build, test, server } = viteBuildConfig;
    const buildOutputPath = normalizeOutputPath(build == null ? void 0 : build.outDir, projectRoot, workspaceRoot, 'dist');
    const isBuildable = (build == null ? void 0 : build.lib) || (build == null ? void 0 : (_build_rollupOptions = build.rollupOptions) == null ? void 0 : _build_rollupOptions.input) || (0, _fs.existsSync)((0, _path.join)(workspaceRoot, projectRoot, 'index.html'));
    const hasServeConfig = Boolean(server);
    const reportsDirectoryPath = normalizeOutputPath(test == null ? void 0 : (_test_coverage = test.coverage) == null ? void 0 : _test_coverage.reportsDirectory, projectRoot, workspaceRoot, 'coverage');
    return {
        buildOutputs: [
            buildOutputPath
        ],
        testOutputs: [
            reportsDirectoryPath
        ],
        hasTest: !!test,
        isBuildable,
        hasServeConfig
    };
}
function normalizeOutputPath(outputPath, projectRoot, workspaceRoot, path) {
    if (!outputPath) {
        if (projectRoot === '.') {
            return `{projectRoot}/${path}`;
        } else {
            return `{workspaceRoot}/${path}/{projectRoot}`;
        }
    } else {
        if ((0, _path.isAbsolute)(outputPath)) {
            return `{workspaceRoot}/${(0, _path.relative)(workspaceRoot, outputPath)}`;
        } else {
            if (outputPath.startsWith('..')) {
                return (0, _path.join)('{workspaceRoot}', (0, _path.join)(projectRoot, outputPath));
            } else {
                return (0, _path.join)('{projectRoot}', outputPath);
            }
        }
    }
}
function normalizeOptions(options) {
    var _options, _options1, _options2, _options3, _options4, _options5;
    options != null ? options : options = {};
    var _buildTargetName;
    (_buildTargetName = (_options = options).buildTargetName) != null ? _buildTargetName : _options.buildTargetName = 'build';
    var _serveTargetName;
    (_serveTargetName = (_options1 = options).serveTargetName) != null ? _serveTargetName : _options1.serveTargetName = 'serve';
    var _previewTargetName;
    (_previewTargetName = (_options2 = options).previewTargetName) != null ? _previewTargetName : _options2.previewTargetName = 'preview';
    var _testTargetName;
    (_testTargetName = (_options3 = options).testTargetName) != null ? _testTargetName : _options3.testTargetName = 'test';
    var _serveStaticTargetName;
    (_serveStaticTargetName = (_options4 = options).serveStaticTargetName) != null ? _serveStaticTargetName : _options4.serveStaticTargetName = 'serve-static';
    var _typecheckTargetName;
    (_typecheckTargetName = (_options5 = options).typecheckTargetName) != null ? _typecheckTargetName : _options5.typecheckTargetName = 'typecheck';
    return options;
}

//# sourceMappingURL=plugin.js.map