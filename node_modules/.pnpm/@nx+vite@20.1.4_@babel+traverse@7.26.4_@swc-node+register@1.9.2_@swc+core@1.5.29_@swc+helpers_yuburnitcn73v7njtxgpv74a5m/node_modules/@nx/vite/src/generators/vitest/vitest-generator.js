"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    vitestGenerator: function() {
        return vitestGenerator;
    },
    vitestGeneratorInternal: function() {
        return vitestGeneratorInternal;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _generatorutils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _versions = require("../../utils/versions");
const _js = require("@nx/js");
const _path = require("path");
const _ensuredependencies = require("../../utils/ensure-dependencies");
function vitestGenerator(tree, schema, hasPlugin = false) {
    return vitestGeneratorInternal(tree, _extends._({
        addPlugin: false
    }, schema), hasPlugin);
}
async function vitestGeneratorInternal(tree, schema, hasPlugin = false) {
    var _nxJson_plugins;
    var // Setting default to jsdom since it is the most common use case (React, Web).
    // The @nx/js:lib generator specifically sets this to node to be more generic.
    _schema;
    var _testEnvironment;
    (_testEnvironment = (_schema = schema).testEnvironment) != null ? _testEnvironment : _schema.testEnvironment = 'jsdom';
    const tasks = [];
    const { root, projectType } = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    const isRootProject = root === '.';
    tasks.push(await (0, _js.initGenerator)(tree, _extends._({}, schema, {
        skipFormat: true
    })));
    const initTask = await (0, _init.default)(tree, {
        skipFormat: true,
        addPlugin: schema.addPlugin
    });
    tasks.push(initTask);
    tasks.push((0, _ensuredependencies.ensureDependencies)(tree, schema));
    const nxJson = (0, _devkit.readNxJson)(tree);
    const hasPluginCheck = (_nxJson_plugins = nxJson.plugins) == null ? void 0 : _nxJson_plugins.some((p)=>(typeof p === 'string' ? p === '@nx/vite/plugin' : p.plugin === '@nx/vite/plugin') || hasPlugin);
    if (!hasPluginCheck) {
        var _schema_testTarget;
        const testTarget = (_schema_testTarget = schema.testTarget) != null ? _schema_testTarget : 'test';
        (0, _generatorutils.addOrChangeTestTarget)(tree, schema, testTarget);
    }
    if (!schema.skipViteConfig) {
        if (schema.uiFramework === 'react') {
            (0, _generatorutils.createOrEditViteConfig)(tree, {
                project: schema.project,
                includeLib: projectType === 'library',
                includeVitest: true,
                inSourceTests: schema.inSourceTests,
                rollupOptionsExternal: [
                    "'react'",
                    "'react-dom'",
                    "'react/jsx-runtime'"
                ],
                imports: [
                    schema.compiler === 'swc' ? `import react from '@vitejs/plugin-react-swc'` : `import react from '@vitejs/plugin-react'`
                ],
                plugins: [
                    'react()'
                ],
                coverageProvider: schema.coverageProvider
            }, true);
        } else {
            (0, _generatorutils.createOrEditViteConfig)(tree, _extends._({}, schema, {
                includeVitest: true,
                includeLib: projectType === 'library'
            }), true);
        }
    }
    createFiles(tree, schema, root);
    updateTsConfig(tree, schema, root, projectType);
    const coverageProviderDependency = getCoverageProviderDependency(schema.coverageProvider);
    const installCoverageProviderTask = (0, _devkit.addDependenciesToPackageJson)(tree, {}, coverageProviderDependency);
    tasks.push(installCoverageProviderTask);
    // Setup workspace config file (https://vitest.dev/guide/workspace.html)
    if (!isRootProject && !tree.exists(`vitest.workspace.ts`) && !tree.exists(`vitest.workspace.js`) && !tree.exists(`vitest.workspace.json`) && !tree.exists(`vitest.projects.ts`) && !tree.exists(`vitest.projects.js`) && !tree.exists(`vitest.projects.json`)) {
        tree.write('vitest.workspace.ts', `export default ['**/*/vite.config.{ts,mts}', '**/*/vitest.config.{ts,mts}'];`);
    }
    if (!schema.skipFormat) {
        await (0, _devkit.formatFiles)(tree);
    }
    return (0, _devkit.runTasksInSerial)(...tasks);
}
function updateTsConfig(tree, options, projectRoot, projectType) {
    const setupFile = tryFindSetupFile(tree, projectRoot);
    if (tree.exists((0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.spec.json'))) {
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.spec.json'), (json)=>{
            var _json_compilerOptions_types, _json_compilerOptions;
            if (!((_json_compilerOptions = json.compilerOptions) == null ? void 0 : (_json_compilerOptions_types = _json_compilerOptions.types) == null ? void 0 : _json_compilerOptions_types.includes('vitest'))) {
                var _json_compilerOptions1;
                if ((_json_compilerOptions1 = json.compilerOptions) == null ? void 0 : _json_compilerOptions1.types) {
                    json.compilerOptions.types.push('vitest');
                } else {
                    var _json;
                    var _compilerOptions;
                    (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
                    json.compilerOptions.types = [
                        'vitest'
                    ];
                }
            }
            if (setupFile) {
                var _json_files;
                json.files = [
                    ...(_json_files = json.files) != null ? _json_files : [],
                    setupFile
                ];
            }
            return json;
        });
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.json'), (json)=>{
            if (json.references && !json.references.some((r)=>r.path === './tsconfig.spec.json')) {
                json.references.push({
                    path: './tsconfig.spec.json'
                });
            }
            return json;
        });
    } else {
        (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.json'), (json)=>{
            var _json_compilerOptions_types, _json_compilerOptions;
            if (!((_json_compilerOptions = json.compilerOptions) == null ? void 0 : (_json_compilerOptions_types = _json_compilerOptions.types) == null ? void 0 : _json_compilerOptions_types.includes('vitest'))) {
                var _json_compilerOptions1;
                if ((_json_compilerOptions1 = json.compilerOptions) == null ? void 0 : _json_compilerOptions1.types) {
                    json.compilerOptions.types.push('vitest');
                } else {
                    var _json;
                    var _compilerOptions;
                    (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
                    json.compilerOptions.types = [
                        'vitest'
                    ];
                }
            }
            return json;
        });
    }
    let runtimeTsconfigPath = (0, _devkit.joinPathFragments)(projectRoot, projectType === 'application' ? 'tsconfig.app.json' : 'tsconfig.lib.json');
    if (options.runtimeTsconfigFileName) {
        runtimeTsconfigPath = (0, _devkit.joinPathFragments)(projectRoot, options.runtimeTsconfigFileName);
        if (!tree.exists(runtimeTsconfigPath)) {
            throw new Error(`Cannot find the specified runtimeTsConfigFileName ("${options.runtimeTsconfigFileName}") at the project root "${projectRoot}".`);
        }
    }
    if (tree.exists(runtimeTsconfigPath)) {
        (0, _devkit.updateJson)(tree, runtimeTsconfigPath, (json)=>{
            if (options.inSourceTests) {
                var _json_compilerOptions;
                var _types;
                ((_types = (_json_compilerOptions = json.compilerOptions).types) != null ? _types : _json_compilerOptions.types = []).push('vitest/importMeta');
            } else {
                const uniqueExclude = new Set([
                    ...json.exclude || [],
                    'vite.config.ts',
                    'vite.config.mts',
                    'vitest.config.ts',
                    'vitest.config.mts',
                    'src/**/*.test.ts',
                    'src/**/*.spec.ts',
                    'src/**/*.test.tsx',
                    'src/**/*.spec.tsx',
                    'src/**/*.test.js',
                    'src/**/*.spec.js',
                    'src/**/*.test.jsx',
                    'src/**/*.spec.jsx'
                ]);
                json.exclude = [
                    ...uniqueExclude
                ];
            }
            if (setupFile) {
                var _json_exclude;
                json.exclude = [
                    ...(_json_exclude = json.exclude) != null ? _json_exclude : [],
                    setupFile
                ];
            }
            return json;
        });
    } else {
        _devkit.logger.warn(`Couldn't find a runtime tsconfig file at ${runtimeTsconfigPath} to exclude the test files from. ` + `If you're using a different filename for your runtime tsconfig, please provide it with the '--runtimeTsconfigFileName' flag.`);
    }
}
function createFiles(tree, options, projectRoot) {
    (0, _devkit.generateFiles)(tree, (0, _path.join)(__dirname, 'files'), projectRoot, _extends._({
        tmpl: ''
    }, options, {
        projectRoot,
        offsetFromRoot: (0, _devkit.offsetFromRoot)(projectRoot)
    }));
}
function getCoverageProviderDependency(coverageProvider) {
    switch(coverageProvider){
        case 'v8':
            return {
                '@vitest/coverage-v8': _versions.vitestCoverageV8Version
            };
        case 'istanbul':
            return {
                '@vitest/coverage-istanbul': _versions.vitestCoverageIstanbulVersion
            };
        default:
            return {
                '@vitest/coverage-v8': _versions.vitestCoverageV8Version
            };
    }
}
function tryFindSetupFile(tree, projectRoot) {
    const setupFile = (0, _devkit.joinPathFragments)('src', 'test-setup.ts');
    if (tree.exists((0, _devkit.joinPathFragments)(projectRoot, setupFile))) {
        return setupFile;
    }
}
const _default = vitestGenerator;

//# sourceMappingURL=vitest-generator.js.map