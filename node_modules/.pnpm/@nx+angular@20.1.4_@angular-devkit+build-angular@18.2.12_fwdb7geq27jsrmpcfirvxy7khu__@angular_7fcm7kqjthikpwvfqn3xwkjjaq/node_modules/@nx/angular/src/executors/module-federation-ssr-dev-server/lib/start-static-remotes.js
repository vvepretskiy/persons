"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startStaticRemotes = startStaticRemotes;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const file_server_impl_1 = tslib_1.__importDefault(require("@nx/web/src/executors/file-server/file-server.impl"));
const path_1 = require("path");
const fs_1 = require("fs");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
function startStaticRemotes(ssrStaticRemotesConfig, context, options) {
    if (ssrStaticRemotesConfig.remotes.length === 0) {
        return (0, async_iterable_1.createAsyncIterable)(({ next, done }) => {
            next({ success: true });
            done();
        });
    }
    // The directories are usually generated with /browser and /server suffixes so we need to copy them to a common directory
    const commonOutputDirectory = (0, path_1.join)(devkit_1.workspaceRoot, 'tmp/static-remotes');
    for (const app of ssrStaticRemotesConfig.remotes) {
        const remoteConfig = ssrStaticRemotesConfig.config[app];
        (0, fs_1.cpSync)(remoteConfig.outputPath, (0, path_1.join)(commonOutputDirectory, remoteConfig.urlSegment), {
            force: true,
            recursive: true,
        });
    }
    const staticRemotesIter = (0, file_server_impl_1.default)({
        cors: true,
        watch: false,
        staticFilePath: commonOutputDirectory,
        parallel: false,
        spa: false,
        withDeps: false,
        host: options.host,
        port: options.staticRemotesPort,
        ssl: options.ssl,
        sslCert: options.sslCert,
        sslKey: options.sslKey,
        cacheSeconds: -1,
    }, context);
    return staticRemotesIter;
}
