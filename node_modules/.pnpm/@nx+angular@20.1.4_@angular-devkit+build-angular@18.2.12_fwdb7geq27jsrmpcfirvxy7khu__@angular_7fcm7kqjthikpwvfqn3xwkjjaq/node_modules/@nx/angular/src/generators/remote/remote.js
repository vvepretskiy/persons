"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remote = remote;
const devkit_1 = require("@nx/devkit");
const project_name_and_root_utils_1 = require("@nx/devkit/src/generators/project-name-and-root-utils");
const ts_solution_setup_1 = require("@nx/js/src/utils/typescript/ts-solution-setup");
const versions_1 = require("@nx/js/src/utils/versions");
const test_runners_1 = require("../../utils/test-runners");
const application_1 = require("../application/application");
const setup_mf_1 = require("../setup-mf/setup-mf");
const add_mf_env_to_inputs_1 = require("../utils/add-mf-env-to-inputs");
const lib_1 = require("./lib");
async function remote(tree, schema) {
    (0, ts_solution_setup_1.assertNotUsingTsSolutionSetup)(tree, 'angular', 'remote');
    const { typescriptConfiguration = true, ...options } = schema;
    options.standalone = options.standalone ?? true;
    const projects = (0, devkit_1.getProjects)(tree);
    if (options.host && !projects.has(options.host)) {
        throw new Error(`The name of the application to be used as the host app does not exist. (${options.host})`);
    }
    await (0, project_name_and_root_utils_1.ensureProjectName)(tree, options, 'application');
    const { projectName: remoteProjectName } = await (0, project_name_and_root_utils_1.determineProjectNameAndRootOptions)(tree, {
        name: options.name,
        projectType: 'application',
        directory: options.directory,
    });
    const REMOTE_NAME_REGEX = '^[a-zA-Z_$][a-zA-Z_$0-9]*$';
    const remoteNameRegex = new RegExp(REMOTE_NAME_REGEX);
    if (!remoteNameRegex.test(remoteProjectName)) {
        throw new Error((0, devkit_1.stripIndents) `Invalid remote name: ${remoteProjectName}. Remote project names must:
       - Start with a letter, dollar sign ($) or underscore (_)
       - Followed by any valid character (letters, digits, underscores, or dollar signs)
      The regular expression used is ${REMOTE_NAME_REGEX}.`);
    }
    const port = options.port ?? (0, lib_1.findNextAvailablePort)(tree);
    const appInstallTask = await (0, application_1.applicationGenerator)(tree, {
        ...options,
        standalone: options.standalone,
        routing: true,
        port,
        skipFormat: true,
        bundler: 'webpack',
    });
    const skipE2E = !options.e2eTestRunner || options.e2eTestRunner === test_runners_1.E2eTestRunner.None;
    await (0, setup_mf_1.setupMf)(tree, {
        appName: remoteProjectName,
        mfType: 'remote',
        routing: true,
        host: options.host,
        port,
        skipPackageJson: options.skipPackageJson,
        skipFormat: true,
        skipE2E,
        e2eProjectName: skipE2E ? undefined : `${remoteProjectName}-e2e`,
        standalone: options.standalone,
        prefix: options.prefix,
        typescriptConfiguration,
        setParserOptionsProject: options.setParserOptionsProject,
    });
    const installTasks = [appInstallTask];
    if (!options.skipPackageJson) {
        const installSwcHelpersTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
            '@swc/helpers': versions_1.swcHelpersVersion,
        });
        installTasks.push(installSwcHelpersTask);
    }
    if (options.ssr) {
        let ssrInstallTask = await (0, lib_1.updateSsrSetup)(tree, {
            appName: remoteProjectName,
            port,
            typescriptConfiguration,
            standalone: options.standalone,
            skipPackageJson: options.skipPackageJson,
        });
        installTasks.push(ssrInstallTask);
    }
    (0, add_mf_env_to_inputs_1.addMfEnvToTargetDefaultInputs)(tree);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...installTasks);
}
exports.default = remote;
