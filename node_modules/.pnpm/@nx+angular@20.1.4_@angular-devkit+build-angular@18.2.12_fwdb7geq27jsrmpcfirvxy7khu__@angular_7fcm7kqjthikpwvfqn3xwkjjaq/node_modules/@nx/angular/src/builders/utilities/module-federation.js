"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDynamicRemotes = getDynamicRemotes;
exports.getStaticRemotes = getStaticRemotes;
exports.validateDevRemotes = validateDevRemotes;
exports.getDynamicMfManifestFile = getDynamicMfManifestFile;
const path_1 = require("path");
const fs_1 = require("fs");
const devkit_1 = require("@nx/devkit");
const internal_1 = require("@nx/js/src/internal");
function getDynamicRemotes(project, context, workspaceProjects, remotesToSkip, pathToManifestFile) {
    pathToManifestFile ??= getDynamicMfManifestFile(project, context.workspaceRoot);
    // check for dynamic remotes
    // we should only check for dynamic based on what we generate
    // and fallback to empty array
    if (!pathToManifestFile || !(0, fs_1.existsSync)(pathToManifestFile)) {
        return [];
    }
    const moduleFederationManifestJson = (0, fs_1.readFileSync)(pathToManifestFile, 'utf-8');
    if (!moduleFederationManifestJson) {
        return [];
    }
    // This should have shape of
    // {
    //   "remoteName": "remoteLocation",
    // }
    const parsedManifest = JSON.parse(moduleFederationManifestJson);
    if (!Object.keys(parsedManifest).every((key) => typeof key === 'string' && typeof parsedManifest[key] === 'string')) {
        return [];
    }
    const allDynamicRemotes = Object.entries(parsedManifest)
        .map(([remoteName]) => remoteName)
        .filter((r) => !remotesToSkip.has(r));
    const remotesNotInWorkspace = [];
    const dynamicRemotes = allDynamicRemotes.filter((remote) => {
        if (!workspaceProjects[remote]) {
            remotesNotInWorkspace.push(remote);
            return false;
        }
        return true;
    });
    if (remotesNotInWorkspace.length > 0) {
        devkit_1.logger.warn(`Skipping serving ${remotesNotInWorkspace.join(', ')} as they could not be found in the workspace. Ensure they are served correctly.`);
    }
    return dynamicRemotes;
}
function getModuleFederationConfig(tsconfigPath, workspaceRoot, projectRoot) {
    const moduleFederationConfigPathJS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.js');
    const moduleFederationConfigPathTS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.ts');
    let moduleFederationConfigPath = moduleFederationConfigPathJS;
    let cleanupTranspiler = () => { };
    if ((0, fs_1.existsSync)(moduleFederationConfigPathTS)) {
        cleanupTranspiler = (0, internal_1.registerTsProject)((0, path_1.join)(workspaceRoot, tsconfigPath));
        moduleFederationConfigPath = moduleFederationConfigPathTS;
    }
    try {
        const config = require(moduleFederationConfigPath);
        cleanupTranspiler();
        return {
            mfeConfig: config.default || config,
            mfConfigPath: moduleFederationConfigPath,
        };
    }
    catch {
        throw new Error(`Could not load ${moduleFederationConfigPath}. Was this project generated with "@nx/angular:host"?`);
    }
}
function getStaticRemotes(project, context, workspaceProjects, remotesToSkip) {
    const { mfeConfig, mfConfigPath } = getModuleFederationConfig(project.targets.build.options.tsConfig, context.workspaceRoot, project.root);
    const remotesConfig = Array.isArray(mfeConfig.remotes) && mfeConfig.remotes.length > 0
        ? mfeConfig.remotes
        : [];
    const allStaticRemotes = remotesConfig
        .map((remoteDefinition) => Array.isArray(remoteDefinition) ? remoteDefinition[0] : remoteDefinition)
        .filter((r) => !remotesToSkip.has(r));
    const remotesNotInWorkspace = [];
    const staticRemotes = allStaticRemotes.filter((remote) => {
        if (!workspaceProjects[remote]) {
            remotesNotInWorkspace.push(remote);
            return false;
        }
        return true;
    });
    if (remotesNotInWorkspace.length > 0) {
        devkit_1.logger.warn(`Skipping serving ${remotesNotInWorkspace.join(', ')} as they could not be found in the workspace. Ensure they are served correctly.`);
    }
    return staticRemotes;
}
function validateDevRemotes(options, workspaceProjects) {
    const invalidDevRemotes = options.devRemotes.filter((remote) => !(typeof remote === 'string'
        ? workspaceProjects[remote]
        : workspaceProjects[remote.remoteName])) ?? [];
    if (invalidDevRemotes.length) {
        throw new Error(invalidDevRemotes.length === 1
            ? `Invalid dev remote provided: ${invalidDevRemotes[0]}.`
            : `Invalid dev remotes provided: ${invalidDevRemotes.join(', ')}.`);
    }
}
function getDynamicMfManifestFile(project, workspaceRoot) {
    // {sourceRoot}/assets/module-federation.manifest.json was the generated
    // path for the manifest file in the past. We now generate the manifest
    // file at {root}/public/module-federation.manifest.json. This check
    // ensures that we can still support the old path for backwards
    // compatibility since old projects may still have the manifest file
    // at the old path.
    return [
        (0, path_1.join)(workspaceRoot, project.root, 'public/module-federation.manifest.json'),
        (0, path_1.join)(workspaceRoot, project.sourceRoot, 'assets/module-federation.manifest.json'),
    ].find((path) => (0, fs_1.existsSync)(path));
}
