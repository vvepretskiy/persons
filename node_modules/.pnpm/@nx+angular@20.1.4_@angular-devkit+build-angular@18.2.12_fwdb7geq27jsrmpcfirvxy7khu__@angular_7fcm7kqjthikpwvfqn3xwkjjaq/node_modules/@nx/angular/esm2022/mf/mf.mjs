let resolveRemoteUrl;
/**
 * @deprecated Use Runtime Helpers from '@module-federation/enhanced/runtime' instead. This will be removed in Nx 22.
 */
export function setRemoteUrlResolver(_resolveRemoteUrl) {
    resolveRemoteUrl = _resolveRemoteUrl;
}
let remoteUrlDefinitions;
/**
 * @deprecated Use init() from '@module-federation/enhanced/runtime' instead. This will be removed in Nx 22.
 * If you have a remote app called `my-remote-app` and you want to use the `http://localhost:4201/mf-manifest.json` as the remote url, you should change it from:
 * ```ts
 * import { setRemoteDefinitions } from '@nx/angular/mf';
 *
 * setRemoteDefinitions({
 *   'my-remote-app': 'http://localhost:4201/mf-manifest.json'
 * });
 * ```
 * to use init():
 * ```ts
 * import { init } from '@module-federation/enhanced/runtime';
 *
 * init({
 *   name: 'host',
 *   remotes: [{
 *     name: 'my-remote-app',
 *     entry: 'http://localhost:4201/mf-manifest.json'
 *   }]
 * });
 * ```
 */
export function setRemoteDefinitions(definitions) {
    remoteUrlDefinitions = definitions;
}
/**
 * @deprecated Use registerRemotes() from '@module-federation/enhanced/runtime' instead. This will be removed in Nx 22.
 * If you set a remote app with `setRemoteDefinition` such as:
 * ```ts
 * import { setRemoteDefinition } from '@nx/angular/mf';
 *
 * setRemoteDefinition(
 *   'my-remote-app',
 *   'http://localhost:4201/mf-manifest.json'
 * );
 * ```
 * change it to use registerRemotes():
 * ```ts
 * import { registerRemotes } from '@module-federation/enhanced/runtime';
 *
 * registerRemotes([
 *  {
 *     name: 'my-remote-app',
 *     entry: 'http://localhost:4201/mf-manifest.json'
 *   }
 * ]);
 * ```
 */
export function setRemoteDefinition(remoteName, remoteUrl) {
    remoteUrlDefinitions ??= {};
    remoteUrlDefinitions[remoteName] = remoteUrl;
}
let remoteModuleMap = new Map();
let remoteContainerMap = new Map();
/**
 * @deprecated Use loadRemote() from '@module-federation/enhanced/runtime' instead. This will be removed in Nx 22.
 * If you set a load a remote with `loadRemoteModule` such as:
 * ```ts
 * import { loadRemoteModule } from '@nx/angular/mf';
 *
 * loadRemoteModule('my-remote-app', './Module').then(m => m.RemoteEntryModule);
 * ```
 * change it to use loadRemote():
 * ```ts
 * import { loadRemote } from '@module-federation/enhanced/runtime';
 *
 * loadRemote<typeof import('my-remote-app/Module')>('my-remote-app/Module').then(m => m.RemoteEntryModule);
 * ```
 */
export async function loadRemoteModule(remoteName, moduleName) {
    const remoteModuleKey = `${remoteName}:${moduleName}`;
    if (remoteModuleMap.has(remoteModuleKey)) {
        return remoteModuleMap.get(remoteModuleKey);
    }
    const container = remoteContainerMap.has(remoteName)
        ? remoteContainerMap.get(remoteName)
        : await loadRemoteContainer(remoteName);
    const factory = await container.get(moduleName);
    const Module = factory();
    remoteModuleMap.set(remoteModuleKey, Module);
    return Module;
}
function loadModule(url) {
    return import(/* webpackIgnore:true */ url);
}
let initialSharingScopeCreated = false;
async function loadRemoteContainer(remoteName) {
    if (!resolveRemoteUrl && !remoteUrlDefinitions) {
        throw new Error('Call setRemoteDefinitions or setRemoteUrlResolver to allow Dynamic Federation to find the remote apps correctly.');
    }
    if (!initialSharingScopeCreated) {
        initialSharingScopeCreated = true;
        await __webpack_init_sharing__('default');
    }
    const remoteUrl = remoteUrlDefinitions
        ? remoteUrlDefinitions[remoteName]
        : await resolveRemoteUrl(remoteName);
    let containerUrl = remoteUrl;
    if (!remoteUrl.endsWith('.mjs') && !remoteUrl.endsWith('.js')) {
        containerUrl = `${remoteUrl}${remoteUrl.endsWith('/') ? '' : '/'}remoteEntry.mjs`;
    }
    const container = await loadModule(containerUrl);
    await container.init(__webpack_share_scopes__.default);
    remoteContainerMap.set(remoteName, container);
    return container;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWYuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9hbmd1bGFyL21mL21mLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLElBQUksZ0JBQTBDLENBQUM7QUFFL0M7O0dBRUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQ2xDLGlCQUEyQztJQUUzQyxnQkFBZ0IsR0FBRyxpQkFBaUIsQ0FBQztBQUN2QyxDQUFDO0FBRUQsSUFBSSxvQkFBNEMsQ0FBQztBQUVqRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxXQUFtQztJQUN0RSxvQkFBb0IsR0FBRyxXQUFXLENBQUM7QUFDckMsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHO0FBQ0gsTUFBTSxVQUFVLG1CQUFtQixDQUFDLFVBQWtCLEVBQUUsU0FBaUI7SUFDdkUsb0JBQW9CLEtBQUssRUFBRSxDQUFDO0lBQzVCLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxHQUFHLFNBQVMsQ0FBQztBQUMvQyxDQUFDO0FBRUQsSUFBSSxlQUFlLEdBQUcsSUFBSSxHQUFHLEVBQW1CLENBQUM7QUFDakQsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBbUIsQ0FBQztBQUVwRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsZ0JBQWdCLENBQUMsVUFBa0IsRUFBRSxVQUFrQjtJQUMzRSxNQUFNLGVBQWUsR0FBRyxHQUFHLFVBQVUsSUFBSSxVQUFVLEVBQUUsQ0FBQztJQUN0RCxJQUFJLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztRQUN6QyxPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELE1BQU0sU0FBUyxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7UUFDbEQsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7UUFDcEMsQ0FBQyxDQUFDLE1BQU0sbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFMUMsTUFBTSxPQUFPLEdBQUcsTUFBTSxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hELE1BQU0sTUFBTSxHQUFHLE9BQU8sRUFBRSxDQUFDO0lBRXpCLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTdDLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxHQUFXO0lBQzdCLE9BQU8sTUFBTSxDQUFDLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFFRCxJQUFJLDBCQUEwQixHQUFHLEtBQUssQ0FBQztBQUV2QyxLQUFLLFVBQVUsbUJBQW1CLENBQUMsVUFBa0I7SUFDbkQsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztRQUMvQyxNQUFNLElBQUksS0FBSyxDQUNiLGtIQUFrSCxDQUNuSCxDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDO1FBQ2hDLDBCQUEwQixHQUFHLElBQUksQ0FBQztRQUNsQyxNQUFNLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxNQUFNLFNBQVMsR0FBRyxvQkFBb0I7UUFDcEMsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQztRQUNsQyxDQUFDLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUV2QyxJQUFJLFlBQVksR0FBRyxTQUFTLENBQUM7SUFDN0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDOUQsWUFBWSxHQUFHLEdBQUcsU0FBUyxHQUN6QixTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQ2pDLGlCQUFpQixDQUFDO0lBQ3BCLENBQUM7SUFFRCxNQUFNLFNBQVMsR0FBRyxNQUFNLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNqRCxNQUFNLFNBQVMsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFdkQsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUM5QyxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgUmVzb2x2ZVJlbW90ZVVybEZ1bmN0aW9uID0gKFxuICByZW1vdGVOYW1lOiBzdHJpbmdcbikgPT4gc3RyaW5nIHwgUHJvbWlzZTxzdHJpbmc+O1xuXG5kZWNsYXJlIGNvbnN0IF9fd2VicGFja19pbml0X3NoYXJpbmdfXzogKHNjb3BlOiAnZGVmYXVsdCcpID0+IFByb21pc2U8dm9pZD47XG5kZWNsYXJlIGNvbnN0IF9fd2VicGFja19zaGFyZV9zY29wZXNfXzogeyBkZWZhdWx0OiB1bmtub3duIH07XG5cbmxldCByZXNvbHZlUmVtb3RlVXJsOiBSZXNvbHZlUmVtb3RlVXJsRnVuY3Rpb247XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIFJ1bnRpbWUgSGVscGVycyBmcm9tICdAbW9kdWxlLWZlZGVyYXRpb24vZW5oYW5jZWQvcnVudGltZScgaW5zdGVhZC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gTnggMjIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZW1vdGVVcmxSZXNvbHZlcihcbiAgX3Jlc29sdmVSZW1vdGVVcmw6IFJlc29sdmVSZW1vdGVVcmxGdW5jdGlvblxuKSB7XG4gIHJlc29sdmVSZW1vdGVVcmwgPSBfcmVzb2x2ZVJlbW90ZVVybDtcbn1cblxubGV0IHJlbW90ZVVybERlZmluaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBpbml0KCkgZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL2VuaGFuY2VkL3J1bnRpbWUnIGluc3RlYWQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIE54IDIyLlxuICogSWYgeW91IGhhdmUgYSByZW1vdGUgYXBwIGNhbGxlZCBgbXktcmVtb3RlLWFwcGAgYW5kIHlvdSB3YW50IHRvIHVzZSB0aGUgYGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMS9tZi1tYW5pZmVzdC5qc29uYCBhcyB0aGUgcmVtb3RlIHVybCwgeW91IHNob3VsZCBjaGFuZ2UgaXQgZnJvbTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXRSZW1vdGVEZWZpbml0aW9ucyB9IGZyb20gJ0BueC9hbmd1bGFyL21mJztcbiAqXG4gKiBzZXRSZW1vdGVEZWZpbml0aW9ucyh7XG4gKiAgICdteS1yZW1vdGUtYXBwJzogJ2h0dHA6Ly9sb2NhbGhvc3Q6NDIwMS9tZi1tYW5pZmVzdC5qc29uJ1xuICogfSk7XG4gKiBgYGBcbiAqIHRvIHVzZSBpbml0KCk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgaW5pdCB9IGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9lbmhhbmNlZC9ydW50aW1lJztcbiAqXG4gKiBpbml0KHtcbiAqICAgbmFtZTogJ2hvc3QnLFxuICogICByZW1vdGVzOiBbe1xuICogICAgIG5hbWU6ICdteS1yZW1vdGUtYXBwJyxcbiAqICAgICBlbnRyeTogJ2h0dHA6Ly9sb2NhbGhvc3Q6NDIwMS9tZi1tYW5pZmVzdC5qc29uJ1xuICogICB9XVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFJlbW90ZURlZmluaXRpb25zKGRlZmluaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIHJlbW90ZVVybERlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHJlZ2lzdGVyUmVtb3RlcygpIGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9lbmhhbmNlZC9ydW50aW1lJyBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiBOeCAyMi5cbiAqIElmIHlvdSBzZXQgYSByZW1vdGUgYXBwIHdpdGggYHNldFJlbW90ZURlZmluaXRpb25gIHN1Y2ggYXM6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc2V0UmVtb3RlRGVmaW5pdGlvbiB9IGZyb20gJ0BueC9hbmd1bGFyL21mJztcbiAqXG4gKiBzZXRSZW1vdGVEZWZpbml0aW9uKFxuICogICAnbXktcmVtb3RlLWFwcCcsXG4gKiAgICdodHRwOi8vbG9jYWxob3N0OjQyMDEvbWYtbWFuaWZlc3QuanNvbidcbiAqICk7XG4gKiBgYGBcbiAqIGNoYW5nZSBpdCB0byB1c2UgcmVnaXN0ZXJSZW1vdGVzKCk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcmVnaXN0ZXJSZW1vdGVzIH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL2VuaGFuY2VkL3J1bnRpbWUnO1xuICpcbiAqIHJlZ2lzdGVyUmVtb3RlcyhbXG4gKiAge1xuICogICAgIG5hbWU6ICdteS1yZW1vdGUtYXBwJyxcbiAqICAgICBlbnRyeTogJ2h0dHA6Ly9sb2NhbGhvc3Q6NDIwMS9tZi1tYW5pZmVzdC5qc29uJ1xuICogICB9XG4gKiBdKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVtb3RlRGVmaW5pdGlvbihyZW1vdGVOYW1lOiBzdHJpbmcsIHJlbW90ZVVybDogc3RyaW5nKSB7XG4gIHJlbW90ZVVybERlZmluaXRpb25zID8/PSB7fTtcbiAgcmVtb3RlVXJsRGVmaW5pdGlvbnNbcmVtb3RlTmFtZV0gPSByZW1vdGVVcmw7XG59XG5cbmxldCByZW1vdGVNb2R1bGVNYXAgPSBuZXcgTWFwPHN0cmluZywgdW5rbm93bj4oKTtcbmxldCByZW1vdGVDb250YWluZXJNYXAgPSBuZXcgTWFwPHN0cmluZywgdW5rbm93bj4oKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgbG9hZFJlbW90ZSgpIGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9lbmhhbmNlZC9ydW50aW1lJyBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiBOeCAyMi5cbiAqIElmIHlvdSBzZXQgYSBsb2FkIGEgcmVtb3RlIHdpdGggYGxvYWRSZW1vdGVNb2R1bGVgIHN1Y2ggYXM6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgbG9hZFJlbW90ZU1vZHVsZSB9IGZyb20gJ0BueC9hbmd1bGFyL21mJztcbiAqXG4gKiBsb2FkUmVtb3RlTW9kdWxlKCdteS1yZW1vdGUtYXBwJywgJy4vTW9kdWxlJykudGhlbihtID0+IG0uUmVtb3RlRW50cnlNb2R1bGUpO1xuICogYGBgXG4gKiBjaGFuZ2UgaXQgdG8gdXNlIGxvYWRSZW1vdGUoKTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBsb2FkUmVtb3RlIH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL2VuaGFuY2VkL3J1bnRpbWUnO1xuICpcbiAqIGxvYWRSZW1vdGU8dHlwZW9mIGltcG9ydCgnbXktcmVtb3RlLWFwcC9Nb2R1bGUnKT4oJ215LXJlbW90ZS1hcHAvTW9kdWxlJykudGhlbihtID0+IG0uUmVtb3RlRW50cnlNb2R1bGUpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUmVtb3RlTW9kdWxlKHJlbW90ZU5hbWU6IHN0cmluZywgbW9kdWxlTmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IHJlbW90ZU1vZHVsZUtleSA9IGAke3JlbW90ZU5hbWV9OiR7bW9kdWxlTmFtZX1gO1xuICBpZiAocmVtb3RlTW9kdWxlTWFwLmhhcyhyZW1vdGVNb2R1bGVLZXkpKSB7XG4gICAgcmV0dXJuIHJlbW90ZU1vZHVsZU1hcC5nZXQocmVtb3RlTW9kdWxlS2V5KTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lciA9IHJlbW90ZUNvbnRhaW5lck1hcC5oYXMocmVtb3RlTmFtZSlcbiAgICA/IHJlbW90ZUNvbnRhaW5lck1hcC5nZXQocmVtb3RlTmFtZSlcbiAgICA6IGF3YWl0IGxvYWRSZW1vdGVDb250YWluZXIocmVtb3RlTmFtZSk7XG5cbiAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IGNvbnRhaW5lci5nZXQobW9kdWxlTmFtZSk7XG4gIGNvbnN0IE1vZHVsZSA9IGZhY3RvcnkoKTtcblxuICByZW1vdGVNb2R1bGVNYXAuc2V0KHJlbW90ZU1vZHVsZUtleSwgTW9kdWxlKTtcblxuICByZXR1cm4gTW9kdWxlO1xufVxuXG5mdW5jdGlvbiBsb2FkTW9kdWxlKHVybDogc3RyaW5nKSB7XG4gIHJldHVybiBpbXBvcnQoLyogd2VicGFja0lnbm9yZTp0cnVlICovIHVybCk7XG59XG5cbmxldCBpbml0aWFsU2hhcmluZ1Njb3BlQ3JlYXRlZCA9IGZhbHNlO1xuXG5hc3luYyBmdW5jdGlvbiBsb2FkUmVtb3RlQ29udGFpbmVyKHJlbW90ZU5hbWU6IHN0cmluZykge1xuICBpZiAoIXJlc29sdmVSZW1vdGVVcmwgJiYgIXJlbW90ZVVybERlZmluaXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NhbGwgc2V0UmVtb3RlRGVmaW5pdGlvbnMgb3Igc2V0UmVtb3RlVXJsUmVzb2x2ZXIgdG8gYWxsb3cgRHluYW1pYyBGZWRlcmF0aW9uIHRvIGZpbmQgdGhlIHJlbW90ZSBhcHBzIGNvcnJlY3RseS4nXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaW5pdGlhbFNoYXJpbmdTY29wZUNyZWF0ZWQpIHtcbiAgICBpbml0aWFsU2hhcmluZ1Njb3BlQ3JlYXRlZCA9IHRydWU7XG4gICAgYXdhaXQgX193ZWJwYWNrX2luaXRfc2hhcmluZ19fKCdkZWZhdWx0Jyk7XG4gIH1cblxuICBjb25zdCByZW1vdGVVcmwgPSByZW1vdGVVcmxEZWZpbml0aW9uc1xuICAgID8gcmVtb3RlVXJsRGVmaW5pdGlvbnNbcmVtb3RlTmFtZV1cbiAgICA6IGF3YWl0IHJlc29sdmVSZW1vdGVVcmwocmVtb3RlTmFtZSk7XG5cbiAgbGV0IGNvbnRhaW5lclVybCA9IHJlbW90ZVVybDtcbiAgaWYgKCFyZW1vdGVVcmwuZW5kc1dpdGgoJy5tanMnKSAmJiAhcmVtb3RlVXJsLmVuZHNXaXRoKCcuanMnKSkge1xuICAgIGNvbnRhaW5lclVybCA9IGAke3JlbW90ZVVybH0ke1xuICAgICAgcmVtb3RlVXJsLmVuZHNXaXRoKCcvJykgPyAnJyA6ICcvJ1xuICAgIH1yZW1vdGVFbnRyeS5tanNgO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVyID0gYXdhaXQgbG9hZE1vZHVsZShjb250YWluZXJVcmwpO1xuICBhd2FpdCBjb250YWluZXIuaW5pdChfX3dlYnBhY2tfc2hhcmVfc2NvcGVzX18uZGVmYXVsdCk7XG5cbiAgcmVtb3RlQ29udGFpbmVyTWFwLnNldChyZW1vdGVOYW1lLCBjb250YWluZXIpO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuIl19